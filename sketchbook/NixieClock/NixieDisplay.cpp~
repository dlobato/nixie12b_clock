#include "NixieDisplay.h"
#include <SPI.h>

void NixieDisplay_setup(){
  pinMode(SS,OUTPUT);
  digitalWrite(SS,HIGH);
  SPI.begin();
  SPI.setBitOrder(MSBFIRST);

  cli();//stop interrupts 
  //set timer1 at 200hz
  //set timer1 interrupt at 1Hz
  TCCR1A = 0;// set entire TCCR1A register to 0
  TCCR1B = 0;// same for TCCR1B
  TCNT1  = 0;//initialize counter value to 0
  // set compare match register for 1hz increments
  OCR1A = round((float)F_CPU/((float)(8*DISPLAY_UPDATE_F))-1);
  // turn on CTC mode
  TCCR1B |= (1 << WGM12);
  // Set CS12 and CS10 bits for 1024 prescaler
  //TCCR1B |= (1 << CS12) | (1 << CS10);  
  TCCR1B |= (1 << CS11);  
  // enable timer compare interrupt
  TIMSK1 |= (1 << OCIE1A);
  sei();//allow interrupts
}

// HV5812 has a 20 bit shift register. Arduino shitfout sends 1byte (8bits) at a time
// So 3bytes (24bits) where the 4MSBs are ignored. XXXX(0_20)(O_19)....(0_1)
// The wiring O_15 = dp, 0_14..O_11 = controls anodes, 0_10..0_1 = control digits
// 0=on 1=off
byte data[3];//data[0]=XXXXO_20..O_17, data[1]=O_16..O_9, data[2]=O_8..O_1 
word digit;

void NixieDisplay_displayDigit(char digitn, char digit_value, char dp){
  if (digit_value>=0 && digit_value<10)
    digit = (1<<digit_value);
  data[0] = 0;
  data[1] = (byte)(1 << (digitn+2)) | (byte)(digit >> 8);
  if (dp)
    data[1] |= 0x40;
  data[2] = (byte)digit;
  
  digitalWrite(SS, LOW);
  SPI.transfer(~data[0]);//high byte not used
  SPI.transfer(~data[1]);
  SPI.transfer(~data[2]);
  digitalWrite(SS, HIGH);
}

void NixieDisplay_displayDigits(char hd, char hu, char md, char mu, char dp){}
  
